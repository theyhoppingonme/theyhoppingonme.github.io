<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GM Visual Sandbox</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #252526;
            --border-color: #3e3e42;
            --accent-color: #007acc;
            --text-color: #d4d4d4;
            --highlight: #add6ff;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Layout */
        #sidebar {
            width: 320px;
            background-color: var(--panel-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            flex-shrink: 0;
        }

        #workspace {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #111;
            cursor: crosshair;
        }

        /* Controls */
        h3 { margin: 10px 0 5px 0; font-size: 14px; text-transform: uppercase; color: #888; }
        .control-group { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        
        button {
            background-color: var(--border-color);
            color: white;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
            transition: background 0.2s;
        }
        button:hover { background-color: var(--accent-color); }
        button.danger { background-color: #a33; }
        button.danger:hover { background-color: #d44; }

        input[type="number"], input[type="text"] {
            background: #111;
            border: 1px solid var(--border-color);
            color: white;
            padding: 5px;
            width: 80px;
            margin-right: 5px;
        }

        textarea {
            width: 100%;
            height: 100px;
            background: #111;
            border: 1px solid var(--border-color);
            color: #ccc;
            font-family: monospace;
            font-size: 11px;
            resize: vertical;
            white-space: pre;
            overflow-x: scroll;
        }

        /* Palette */
        #palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 8px;
            margin-top: 5px;
        }

        .palette-item {
            width: 64px;
            height: 64px;
            background: #333;
            border: 2px solid transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            border-radius: 4px;
        }

        .palette-item img {
            max-width: 100%;
            max-height: 100%;
            image-rendering: pixelated;
            pointer-events: none;
        }

        .palette-item:hover { background: #444; }
        .palette-item.active { border-color: var(--accent-color); background: #2a2d3e; }
        .palette-item .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 4px;
            font-size: 10px;
            white-space: nowrap;
            display: none;
            z-index: 10;
        }
        .palette-item:hover .tooltip { display: block; }

        /* Canvas Overlay */
        #canvas-wrapper {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 1px solid #444;
            position: relative;
        }

        #resize-handle {
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            background: var(--accent-color);
            cursor: se-resize;
            border-radius: 50%;
            z-index: 100;
        }

    </style>
</head>
<body>

<div id="sidebar">
    <div class="control-group">
        <h3>Scene Controls</h3>
        <button id="btn-save">Save JSON</button>
        <button id="btn-load-trigger">Load JSON</button>
        <input type="file" id="file-input" style="display: none" accept=".json">
        <div style="margin-top: 8px; display: flex; align-items: center;">
            <label style="font-size: 12px; margin-right: 5px;">W:</label>
            <input type="number" id="inp-width" value="280">
            <label style="font-size: 12px; margin-right: 5px;">H:</label>
            <input type="number" id="inp-height" value="280">
        </div>
    </div>

    <div class="control-group">
        <h3>Selected Instance</h3>
        <div id="selection-controls" style="opacity: 0.5; pointer-events: none;">
            <div style="margin-bottom: 5px;">
                <label style="font-size: 12px;">Sprite:</label> 
                <span id="sel-sprite-name" style="font-size:12px; color: var(--highlight);">None</span>
            </div>
            <div style="margin-bottom: 5px;">
                <label style="font-size: 12px;">Pos:</label> 
                <span id="sel-pos" style="font-size:12px; font-family: monospace;">0, 0</span>
            </div>
            <div style="margin-bottom: 8px;">
                <label style="font-size: 12px;">XScale:</label>
                <input type="number" id="inp-xscale" step="0.1" value="1">
            </div>
            <button class="danger" id="btn-delete">Delete</button>
        </div>
    </div>

    <div class="control-group">
        <h3>Sprite Palette</h3>
        <div id="palette"></div>
    </div>

    <div class="control-group" style="flex-grow: 1; display: flex; flex-direction: column;">
        <h3>GameMaker GML IO</h3>
        <div style="margin-bottom: 5px;">
            <button id="btn-compile">Compile</button>
            <button id="btn-import">Import Code</button>
        </div>
        <textarea id="code-io" placeholder="Paste net_quick_effect lines here to import, or click Compile to generate..."></textarea>
    </div>
</div>

<div id="workspace">
    <div id="canvas-wrapper">
        <canvas id="canvas"></canvas>
    </div>
</div>

<script>
/**
 * ASSETS & DATA
 */
const SPRITE_NAMES = [
    "spr_ring_sparkle", "spr_ring_teleport", "spr_blood1", "spr_blood2", 
    "spr_blood3", "spr_ringlose", "spr_shieldbreak", "spr_dust", 
    "spr_eggpack", "spr_roseheart", "spr_eroseheart", "spr_shockparticle", 
    "spr_shieldbreak2", "spr_blackring_sparkle", "spr_blackring_sparkle_purple", 
    "spr_watersplash", "spr_shard_sparkle"
];

const IMAGES = {};
let imagesLoadedCount = 0;

const state = {
    canvasWidth: 280,
    canvasHeight: 280,
    camera: { x: 0, y: 0, zoom: 1 },
    instances: [], // { id, sprite, x, y, xscale }
    activeSprite: SPRITE_NAMES[0],
    selection: null, 
    isDragging: false,
    dragStart: { x: 0, y: 0 },
    dragMode: null // 'pan', 'move'
};

const uid = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const wrapper = document.getElementById('canvas-wrapper');
const paletteContainer = document.getElementById('palette');
const inpXScale = document.getElementById('inp-xscale');
const selectionControls = document.getElementById('selection-controls');
const codeIO = document.getElementById('code-io');
const inpWidth = document.getElementById('inp-width');
const inpHeight = document.getElementById('inp-height');

function init() {
    SPRITE_NAMES.forEach(name => {
        const img = new Image();
        img.src = `sprites/${name}.png`;
        img.onload = () => {
            imagesLoadedCount++;
            if(imagesLoadedCount === SPRITE_NAMES.length) render();
        };

        img.onerror = () => { 
            console.error(`Missing sprite: ${name}`);
            imagesLoadedCount++;
        };
        IMAGES[name] = img;

        const el = document.createElement('div');
        el.className = 'palette-item';
        if(name === state.activeSprite) el.classList.add('active');
        el.innerHTML = `<img src="sprites/${name}.png"><div class="tooltip">${name}</div>`;
        el.onclick = () => setActiveSprite(name, el);
        paletteContainer.appendChild(el);
    });

    resizeCanvas();
    render();
    setupEvents();
}

function setActiveSprite(name, element) {
    state.activeSprite = name;
    document.querySelectorAll('.palette-item').forEach(e => e.classList.remove('active'));
    element.classList.add('active');
}

function resizeCanvas() {
    state.canvasWidth = parseInt(inpWidth.value) || 280;
    state.canvasHeight = parseInt(inpHeight.value) || 280;
    canvas.width = state.canvasWidth;
    canvas.height = state.canvasHeight;
    wrapper.style.width = state.canvasWidth + 'px';
    wrapper.style.height = state.canvasHeight + 'px';
    render();
}

function render() {
    ctx.fillStyle = "#222";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();

    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    ctx.translate(cx, cy);
    ctx.scale(state.camera.zoom, state.camera.zoom);
    ctx.translate(-cx, -cy);
    ctx.translate(state.camera.x, state.camera.y);

    ctx.beginPath();
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 1 / state.camera.zoom;
    // Draw grid relative to center (0,0) logic
    const originX = cx; 
    const originY = cy;
    
    ctx.moveTo(originX - 10000, originY);
    ctx.lineTo(originX + 10000, originY);
    ctx.moveTo(originX, originY - 10000);
    ctx.lineTo(originX, originY + 10000);
    ctx.stroke();

    state.instances.forEach(inst => {
        const img = IMAGES[inst.sprite];
        if(!img || !img.complete) return;

        ctx.save();
        const drawX = originX + inst.x;
        const drawY = originY + inst.y;

        ctx.translate(drawX, drawY);
        
        ctx.scale(inst.xscale, 1);

        ctx.drawImage(img, -img.width/2, -img.height/2);

        if (state.selection === inst.id) {
            ctx.scale(1/inst.xscale, 1);
            
            const w = img.width * Math.abs(inst.xscale);
            const h = img.height;
            
            ctx.strokeStyle = "#00ff00";
            ctx.lineWidth = 2 / state.camera.zoom;
            ctx.strokeRect(-w/2, -h/2, w, h);
        }

        ctx.restore();
    });

    ctx.restore();
}

function screenToWorld(sx, sy) {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    const x = (sx - cx) / state.camera.zoom + cx - state.camera.x;
    const y = (sy - cy) / state.camera.zoom + cy - state.camera.y;
    
    return {
        x: x - cx,
        y: y - cy
    };
}

function setupEvents() {
    
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomSensitivity = 0.001;
        const delta = -e.deltaY * zoomSensitivity;
        const factor = Math.pow(1.1, delta > 0 ? 1 : -1);

        const mouseX = e.offsetX;
        const mouseY = e.offsetY;

        const worldPosBefore = screenToWorld(mouseX, mouseY);

        state.camera.zoom *= factor;
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        state.camera.x = (mouseX - cx) / state.camera.zoom - worldPosBefore.x + (cx - cx);
        state.camera.y = (mouseY - cy) / state.camera.zoom - worldPosBefore.y;

        render();
    });

    canvas.addEventListener('mousedown', (e) => {
        const mPos = screenToWorld(e.offsetX, e.offsetY);
        
        let clickedId = null;
        for (let i = state.instances.length - 1; i >= 0; i--) {
            const inst = state.instances[i];
            const img = IMAGES[inst.sprite];
            const w = img.width * Math.abs(inst.xscale);
            const h = img.height;
            
            if (mPos.x >= inst.x - w/2 && mPos.x <= inst.x + w/2 &&
                mPos.y >= inst.y - h/2 && mPos.y <= inst.y + h/2) {
                clickedId = inst.id;
                break;
            }
        }

        if (clickedId) {
            state.selection = clickedId;
            updateSelectionUI();
            state.dragMode = 'move';
            state.dragStart = { mx: mPos.x, my: mPos.y, ix: state.instances.find(i=>i.id===clickedId).x, iy: state.instances.find(i=>i.id===clickedId).y };
        } else {
            const newInst = {
                id: uid(),
                sprite: state.activeSprite,
                x: mPos.x,
                y: mPos.y,
                xscale: 1
            };
            state.instances.push(newInst);
            state.selection = newInst.id;
            updateSelectionUI();
            
            state.dragMode = 'move';
            state.dragStart = { mx: mPos.x, my: mPos.y, ix: newInst.x, iy: newInst.y };
        }
        
        state.isDragging = true;
        render();
    });

    window.addEventListener('mousemove', (e) => {
        if (!state.isDragging) return;

        const rect = canvas.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        const offsetY = e.clientY - rect.top;
        const mPos = screenToWorld(offsetX, offsetY);

        if (state.dragMode === 'move' && state.selection) {
            const inst = state.instances.find(i => i.id === state.selection);
            if (inst) {
                const dx = mPos.x - state.dragStart.mx;
                const dy = mPos.y - state.dragStart.my;
                inst.x = state.dragStart.ix + dx;
                inst.y = state.dragStart.iy + dy;
                updateSelectionUI();
                render();
            }
        }
    });

    window.addEventListener('mouseup', () => {
        state.isDragging = false;
        state.dragMode = null;
    });

    inpXScale.addEventListener('input', () => {
        if(!state.selection) return;
        const inst = state.instances.find(i => i.id === state.selection);
        if(inst) {
            inst.xscale = parseFloat(inpXScale.value) || 1;
            render();
        }
    });

    document.getElementById('btn-delete').addEventListener('click', () => {
        if(state.selection) {
            state.instances = state.instances.filter(i => i.id !== state.selection);
            state.selection = null;
            updateSelectionUI();
            render();
        }
    });
    
    window.addEventListener('keydown', (e) => {
        if((e.key === 'Delete' || e.key === 'Backspace') && state.selection && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
            state.instances = state.instances.filter(i => i.id !== state.selection);
            state.selection = null;
            updateSelectionUI();
            render();
        }
    });

    inpWidth.addEventListener('change', resizeCanvas);
    inpHeight.addEventListener('change', resizeCanvas);

    document.getElementById('btn-compile').addEventListener('click', compileGML);
    
    document.getElementById('btn-import').addEventListener('click', importGML);

    document.getElementById('btn-save').addEventListener('click', saveJSON);
    document.getElementById('btn-load-trigger').addEventListener('click', () => document.getElementById('file-input').click());
    document.getElementById('file-input').addEventListener('change', loadJSON);
}

function updateSelectionUI() {
    if (state.selection) {
        const inst = state.instances.find(i => i.id === state.selection);
        selectionControls.style.opacity = 1;
        selectionControls.style.pointerEvents = 'auto';
        document.getElementById('sel-sprite-name').innerText = inst.sprite;
        document.getElementById('sel-pos').innerText = `${Math.round(inst.x)}, ${Math.round(inst.y)}`;
        inpXScale.value = inst.xscale;
    } else {
        selectionControls.style.opacity = 0.5;
        selectionControls.style.pointerEvents = 'none';
        document.getElementById('sel-sprite-name').innerText = "None";
        document.getElementById('sel-pos').innerText = "-";
        inpXScale.value = 1;
    }
}

/**
 * GML COMPILER & PARSER
 */
function compileGML() {
    let output = "";
    state.instances.forEach(inst => {
        // net_quick_effect(global.player.x + x_pos, global.player.y + y_pos, sprite, false, x_scale, 0, 0, 0);
        const xPos = Number(inst.x.toFixed(2));
        const yPos = Number(inst.y.toFixed(2));
        const xSc = Number(inst.xscale);
        
        output += `net_quick_effect(global.player.x + ${xPos}, global.player.y + ${yPos}, ${inst.sprite}, false, ${xSc}, 0, 0, 0);\n`;
    });
    codeIO.value = output.trim();
}

function importGML() {
    const code = codeIO.value;
    const regex = /net_quick_effect\(global\.player\.x \+ ([\d\.-]+), global\.player\.y \+ ([\d\.-]+), ([a-zA-Z0-9_]+), false, ([\d\.-]+), 0, 0, 0\);/g;
    
    let match;
    const newInstances = [];
    
    while ((match = regex.exec(code)) !== null) {
        const x = parseFloat(match[1]);
        const y = parseFloat(match[2]);
        const sprite = match[3];
        const xscale = parseFloat(match[4]);
        
        if (SPRITE_NAMES.includes(sprite)) {
            newInstances.push({
                id: uid(),
                sprite: sprite,
                x: x,
                y: y,
                xscale: xscale
            });
        }
    }
    
    if (newInstances.length > 0) {
        state.instances = newInstances;
        state.selection = null;
        updateSelectionUI();
        render();
        alert(`Imported ${newInstances.length} instances.`);
    } else {
        alert("No valid code found or parsing failed.");
    }
}

/**
 * JSON SAVE/LOAD
 */
function saveJSON() {
    const data = {
        canvasWidth: state.canvasWidth,
        canvasHeight: state.canvasHeight,
        zoom: state.camera.zoom,
        instances: state.instances.map(i => ({
            sprite: i.sprite,
            x: i.x,
            y: i.y,
            xscale: i.xscale
        }))
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'scene_data.json';
    a.click();
}

function loadJSON(e) {
    const file = e.target.files[0];
    if(!file) return;
    
    const reader = new FileReader();
    reader.onload = function(evt) {
        try {
            const data = JSON.parse(evt.target.result);
            
            if(data.canvasWidth) {
                inpWidth.value = data.canvasWidth;
                inpHeight.value = data.canvasHeight;
                resizeCanvas();
            }
            
            if(data.zoom) state.camera.zoom = data.zoom;
            
            if(data.instances) {
                state.instances = data.instances.map(i => ({
                    id: uid(),
                    sprite: i.sprite,
                    x: i.x,
                    y: i.y,
                    xscale: i.xscale
                }));
            }
            
            state.selection = null;
            updateSelectionUI();
            render();
        } catch(err) {
            console.error(err);
            alert("Failed to load JSON");
        }
    };
    reader.readAsText(file);
}

window.onload = init;

</script>
</body>
</html>
